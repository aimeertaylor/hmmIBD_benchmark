---
title: 'Additional file 3: Comparative study of isoRelate and hmmIBD'
output: pdf_document
---

# Methods

## Summary of files and variables used

The following summarizes results generated from a comparative study of hmmIBD and isoRelate (Henden L, et al. BioRxiv. 2016). Analyses were based on data generated by artificial recombination (details below). The steps, data and scripts required to reproduce this study are as follows. 

1. Download the hmmIBD_benchmark repository from https://github.com/artaylor85/hmmIBD_benchmark and unzip the pf3k_data directory.
2. Install hmmIBD following instructions at https://github.com/glipsnort/hmmIBD/releases (v2.0.0).
3. Install isoRelate following instructions at https://github.com/bahlolab/isoRelate/releases (results here based on v0.1.0 installed Aug 9th 2017).
4. Set working directory to this source file location.
5. Run $\texttt{Simulate\_chimeric\_genotypes.R}$.
6. Run $\texttt{Run\_isolate\_hmmIBD.R}$. 
7. Run $\texttt{Post\_process\_results.R}$.
8. Run/knit this file. 

```{r setup, include=FALSE}
#===============================================================================
# Default chunk options
#===============================================================================
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, include=TRUE, cache=TRUE, cache.comments = FALSE, fig.pos = 'H', fig.width = 7, dev = 'png', dpi = 300)

# Clear workspace, load libraries, specify magic numbers used
rm(list = ls()) 
inst_pkg_list <- rownames(installed.packages())
if("knitr" %in% inst_pkg_list){# For tables from matrices
  library(knitr) 
} else {
  install.packages("knitr")
  library(knitr)
}

# Magic numbers
load(file = '../pf3k_chimeric_data/Run_isoRelate_hmmIBD_magic_numbers.RData')
attach(Magic_numbers)
load(file = '../pf3k_chimeric_data/Simulate_chimeric_genotypes_Magic_numbers.RData')
attach(Magic_numbers)
rho <- as.character(signif(rho,3))

# Numbers of SNPs
load('../pf3k_chimeric_data/sites.RData')
nsnps <- rep(NA,3)
names(nsnps) <- sites
for(site in sites){
  load(sprintf('../pf3k_chimeric_data/parent_assignment_%s.RData', site))
  nsnps[site] <- nrow(parent_assignment)
  rm(parent_assignment)
}
```


## Simulation of artificially recombined data 

We used artificially recombined data to compare results generated under hmmIBD and isoRelate to a known truth that was not generated under either model. Artificially recombined data were based on the MalariaGen Pf3k samples, pilot release 5.0 (https://www.malariagen.net/projects/pf3k). These data were filtered prior to their use in this comparative study, leaving only single nucleotide polymorphisms (SNPs) in the accessible genome (as defined by Manske M, et al. Nature 2012), and those with a high probability of being monogenomic (as defined by DEploid from Zhu SJ, Almagro-garcia J, Mcvean G. BioRxiv. 2017). The filtered data can be found in $\texttt{pf3k\_data}$. Using $\texttt{Simulate\_chimeric\_genotypes.R}$ we:

1.  Extracted samples from sites with `r min_num` or more samples (Thies, Kassena, Pursat). 
2.  For each site, removed multiallelic SNPs (unsupported by isoRelate) and those with minor allele frequency $\leq$ `r MAF`, leaving `r nsnps` SNPs per sample from `r names(nsnps)`, respectively. 
3.  Calculated and saved allele frequencies and data sets based on the unrecombined data to ensure frequencies were not based on chimeric samples.
4.  For each pairwise comparison within a site, calculated the average identity-by-state, IBS (one minus the genome-wide average SNP difference), and plotted. 
5.  Extracted unrelated pairs (those with IBS < `r cutoff*100` percentile of the empirical IBS distribution). 
6.  Artificially recombined each unrelated sample pair to create a "chimeric child". Recombination was simulated by sampling crossover positions (in base pairs, bp) from an exponential distribution with mean equal to the recombination rate in Morgans, M, per bp (see $\texttt{functions.R}$). 
7. Recorded the parent of each DNA segment in each chimeric child, and plotted the number of crossovers per chromosome averaged over all the chimeric children per site.  

In addition to the above steps, we generated an erroneous copy of each parent and chimeric child. More specifically, for each SNP with probability equal to the genotyping error `r error_prob`, the copied allele was replaced by its biallelic counterpart. 

<!-- UPDATE THIS SECTION WITH PARAMETERS USED IN hmm.c -->
## Experiments to evaluate timing 

Timing experiments were performed on the first `r n_timing_samples_to_run` samples per site (including unrecombined parents and non-erroneous chimeric children), and repeated `r n_timing_repetition` times on a MacBook Air laptop with 1.7 GHz Intel Core i7 processor using the parameter values listed in the table below. Some of the parameter values differ to the defaults provided in order to more closely match the two methods.  

Parameter |  isoRelate | hmmIBD
---------------------------------------------------------------- | ----------  | ----------
genotyping error | `r error_prob`  | 0.001
recombination rate | `r rho` M/bp$\dagger$ | `r  rho` M/bp
minimum no. SNPs per segment | `r min_snps` | NA
minimum length (bp) per segment | `r minimum_length_bp` | NA
Minimum marker spacing (bp) | NA | 0
Minimum informative sites per genome | NA | 0  

Table: Specified parameter values. NA denotes not applicable. $\dagger$In isoRelate, the "recombination rate" is a function of distance in M. The equivalent fixed rate in M/bp in hmmIBD was thus based on the empirical relationship between positions in bp and centimorgans provided in the png_pedmap data set of the isoRelate package. 


## Experiments to evaluate inference 

For each site, IBD segments between `r n_children_to_analyse` "chimeric children" and each of their two parents were inferred under isoRelate and hmmIBD using the parameter values listed in the table above. Accuracy, sensitivity and specificity were calculated as follows, where for a given pairwise comparison and SNP, a true positive is an IBD observation given an IBD state, and a true negative is a not IBD (nIBD) observation given a nIBD state,  

\begin{align}
\text{Accuracy} &= \dfrac{\sum \text{ True positive} + \sum \text{ True negative}}{\text{Number of SNPs}},\\
\text{Sensitivity} &= \dfrac{\sum \text{ True positive}}{\sum \text{ IBD states}},\\
\text{Specificity} &= \dfrac{\sum \text{ True negative}}{\sum \text{ nIBD states}}.
\end{align}

We also compared estimates of the numbers of generations inferred under isoRelate and hmmIBD, and the proportion simulated IBD with the posterior probability of IBD inferred under hmmIBD (the latter was not directly available under v0.1.0 of isoRelate).

To investigate the impact of genotyping error, the entire process was then repeated for the erroneous copies of `r n_children_to_analyse` chimeric children and their parents. We expect error to introduce small and incorrectly inferred segments into otherwise correctly inferred segments of DNA that are both IBD and not. Concomitantly, we expect error to spuriously increase estimates of numbers of generations since most recent common ancestors. 

# Results

## Timing 

```{r} 
time_store <- array(dim = c(length(sites)*n_timing_repetition,2,2), 
                    dimnames = list(paste(sites, rep(1:n_timing_repetition, each = length(sites))), c('isoRelate', 'hmmIBD'), c('real', 'user')))

# hmmIBD
load('../pf3k_chimeric_data/hmmIBD_timing_output.RData')

for(site in sites){
  for(i in 1:n_timing_repetition){
    
    # IsoRelate
    load(sprintf('../pf3k_chimeric_data/IsoRelate_timing_output_%s_%s.RData', site, i))
    
    # Extract
    time_store[paste(site, i), 'isoRelate', 'real'] <- results$time_my_ibd['elapsed']
    time_store[paste(site, i), 'hmmIBD', 'real'] <- time_my_ibd[[paste(site, i)]]['elapsed'] 
    time_store[paste(site, i), 'isoRelate', 'user'] <- results$time_my_ibd['user.child'] + results$time_my_ibd['user.self']
    time_store[paste(site, i), 'hmmIBD', 'user'] <- time_my_ibd[[paste(site, i)]]['user.child'] + time_my_ibd[[paste(site, i)]]['user.self']
  }
}

# Visually report times
kable(time_store[,,'real'], caption = sprintf('Clocktime (sec) per %s samples', n_timing_samples_to_run))

kable(time_store[,,'user'], caption = sprintf('CPU time (sec) per %s samples', n_timing_samples_to_run))

# Report average time (with CIs or range) 
mean_times_real <- colMeans(time_store[,,'real'])
mean_times_user <- colMeans(time_store[,,'user'])

# Standard deviations
se_real <- apply(time_store[,,'real'], 2, sd)
se_user <- apply(time_store[,,'user'], 2, sd)

# Average fold difference
fold_diff <- mean(time_store[,'isoRelate','user']/time_store[,'hmmIBD','user'])
```
```{r, cache.comments = FALSE, echo = FALSE}
# Define function to plot asignments
plot_assignments <- function(comp){
  
  # Determine if a comparison with parent1 or parent2? 
  samples <- strsplit(comp, split = ' ')[[1]]
  child_ind <- grepl(":", samples)
  child <- samples[child_ind]
  parent <- sprintf('parent%s', which(strsplit(child, split = ":" )[[1]] == samples[!child_ind]))
  
  # Exract and colour assignment
  sim <- parent_assignment[,child]
  parentcol <- c(parent1 = 'blue', parent2 = 'pink')
  sim[sim == 'parent1'] <- parentcol['parent1']
  sim[sim == 'parent2'] <- parentcol['parent2']
  
  hap <- hmmIBD_assignment[,comp]
  hap[hap == parent] <- parentcol[parent]
  hap[hap == 'DBD'] <- 'gray'
  hap[is.na(hap)] <- 'black'
  
  iso <- isoRelate_assignment[,comp]
  iso[iso == parent] <- parentcol[parent]
  iso[iso == 'DBD'] <- 'gray'
  iso[is.na(iso)] <- 'black'
  
  # Get chromosome lengths
  chr_length <- read.csv(file = '../pf3k_data/Pf_v3_chrom_length.csv', 
                         skip = 2, header = FALSE)[,'V3']
  
  # Plot set up 
  par(mfrow = c(3,1), mar = c(1,1,1,1))  
  
  # Simulated
  barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
  title(main = 'Simulated')
  legend('bottomright', legend = c('SNP inherited from parent1', 'SNP inherited from parent2'), 
         bty = 'n', 
         col = c(parentcol['parent1'], parentcol['parent2']), lty = 1, lwd = 2, inset = 0.15)
  for(chr in 1:14){
    indices <- which(parent_assignment[,'chrom'] == chr)
    for(ind in indices){
      segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
               x0 = parent_assignment$pos[ind], 
               x1 = parent_assignment$pos[ind], 
               col = sim[ind]) 
    }
  }
  
  # Inferred isoRelate
  barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
  title(main = 'Inferred under isoRelate')
  legend('bottomright', legend = c(sprintf('SNP IBD with %s', parent), 
                                   sprintf('SNP DBD with %s', parent), 'NA'), bty = 'n', 
         col = c(parentcol[parent], 'gray', 'black'), lty = 1, lwd = 2, inset = 0.15)
  for(chr in 1:14){
    indices <- which(parent_assignment$chrom == chr)
    for(ind in indices){
      segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
               x0 = parent_assignment$pos[ind], 
               x1 = parent_assignment$pos[ind], 
               col = iso[ind]) 
    }
  }
  
  # Inferred hmmIBD
  barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
  title(main = 'Inferred under hmmIBD')
  legend('bottomright', legend = c(sprintf('SNP IBD with %s', parent), 
                                   sprintf('SNP DBD with %s', parent), 'NA'), bty = 'n', 
         col = c(parentcol[parent], 'gray', 'black'), lty = 1, lwd = 2, inset = 0.15)  
  for(chr in 1:14){
    indices <- which(parent_assignment$chrom == chr)
    for(ind in indices){
      segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
               x0 = parent_assignment$pos[ind], 
               x1 = parent_assignment$pos[ind], 
               col = hap[ind]) 
    }
  } 
}
```

```{r}
# Define function to extract accuracy, specificity and sensitivity
acc_spec_sens <- function(){
  
  # Accuracy, sensitivity and specificity stores 
  accuracy <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), 
                    dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))
  sensitivity <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), 
                       dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))
  specificity <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), 
                       dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))
  
  for(site in sites){
    
    comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
    parent_assignment <- parent_assignment_sites[[site]] 
    isoRelate_assignment <- isoRelate_assignment_sites[[site]] 
    hmmIBD_assignment <- hmmIBD_assignment_sites[[site]] 
    
    n_snps <- nsnps[site]
    
    for(i in 1:length(comparisons_of_interest)){
      
      # Extract parent of comparison
      samples <- strsplit(comparisons_of_interest[i], ' ')[[1]]
      parent <- sprintf('parent%s', which(strsplit(samples[1], split = ":")[[1]] == samples[2]))
      simulated <- parent_assignment[,strsplit(comparisons_of_interest[i], split = ' ')[[1]][1]]
      positive_simulated <- sum(simulated == parent)
      negative_simulated <- sum(simulated != parent)
      
      # Calculate accuracy isoRelate (not counting NAs)
      inferred_iso <- isoRelate_assignment[,comparisons_of_interest[i]]
      true_positive_iso <- sum(simulated == inferred_iso, na.rm = TRUE)
      true_negative_iso <- sum((simulated != parent) & (inferred_iso == 'DBD'), na.rm = TRUE) 
      accuracy[i, 'isoRelate', site] <- (true_positive_iso + true_negative_iso)/n_snps  
      
      # Calculate accuracy hmmIBD (not counting NAs)
      inferred_hap <- hmmIBD_assignment[,comparisons_of_interest[i]]
      true_positive_hap <- sum(simulated == inferred_hap, na.rm = TRUE)
      true_negative_hap <- sum((simulated != parent) & (inferred_hap == 'DBD'), na.rm = TRUE) 
      accuracy[i, 'hmmIBD', site] <- (true_positive_hap + true_negative_hap)/n_snps  
      
      # Calculate Sensitivity and specificity
      sensitivity[i, 'isoRelate', site] <- true_positive_iso/positive_simulated
      sensitivity[i, 'hmmIBD', site] <- true_positive_hap/positive_simulated
      specificity[i, 'isoRelate', site] <- true_negative_iso/negative_simulated
      specificity[i, 'hmmIBD', site] <- true_negative_hap/negative_simulated
    }
  }
  
  # Summarise for plots below
  mean_accuracy <- apply(accuracy, c(2,3), mean) 
  mean_sensitivity <- apply(sensitivity, c(2,3), mean) 
  mean_specificity <- apply(specificity, c(2,3), mean) 
  
  acc_spec_sens_list <- list(mean_accuracy = mean_accuracy, 
                             mean_sensitivity = mean_sensitivity, 
                             mean_specificity = mean_specificity, 
                             accuracy = accuracy, 
                             sensitivity = sensitivity, 
                             specificity = specificity)
  
  return(acc_spec_sens_list)
} 

```

```{r}
# Define function to plot accuracy, specificity and sensitivity
plot_acc_spec_sens <- function(site){
  
  plot(NULL, ylim = c(0,1), xlim = c(0,1), bty = 'n', main = site, 
       xlab = 'False positive rate (1-specificity)', 
       ylab = 'True positive rate (sensitivity)')
  title(sub = sprintf('Mean accuracy %s (isoRelate) %s (hmmIBD)',
                      round(mean_accuracy[,site],4)['isoRelate'],
                      round(mean_accuracy[,site],4)['hmmIBD']))
  
  points(y = sensitivity[, 'isoRelate', site], x = (1-specificity[, 'isoRelate', site]), 
         col = adjustcolor('darkgreen', alpha.f = 0.5), pch = 20)
  abline(h = mean_sensitivity['isoRelate', site], 
         v = 1-mean_specificity['isoRelate', site], col = 'darkgreen', lty = 'dashed')
  
  points(y = sensitivity[, 'hmmIBD', site], x = (1-specificity[, 'hmmIBD', site]), 
         col = adjustcolor('blue', alpha.f = 0.5), pch = 20)
  abline(h = mean_sensitivity['hmmIBD', site], 
         v = 1-mean_specificity['hmmIBD', site], col = 'blue', lty = 'dashed')
  
  legend('right',  
         col = c('darkgreen', 'blue', 'darkgreen', 'blue'), pch = rep(20, 20, NA, NA), 
         pt.cex =  c(1, 1, 0, 0), lty = c(0, 0, 2, 2), bty = 'n', cex = 0.8, 
         legend = c('isoRelate single comparison', 
                    'hmmIBD single comparison', 
                    'isoRelate mean', 
                    'hmmIBD mean'))
}
```

```{r}
# Define function to plot generations
plot_gen <- function(hmmIBD_output_path, IsoRelate_output_path){
  par(mfrow = c(1,3), pty = 's')
  for(site in sites){
    
    comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
    
    # hmmIBD
    X <- read.table(sprintf(hmmIBD_output_path, site), header = TRUE)
    haplo_21 <- apply(X[,c('sample2', 'sample1')], 1, paste, collapse = ' ')
    ind <- haplo_21 %in% comparisons_of_interest 
    no_gen_hap <- X$N_generation[ind]
    
    # isoRelate (ind as above since assignments have the same dimnames)
    load(sprintf(isoRelate_output_path, site))
    Y <- results$my_parameters
    haplo_21 <- apply(Y[,c('iid2', 'iid1')], 1, paste, collapse = ' ')
    ind <- haplo_21 %in% comparisons_of_interest # all in 21 (ordering)
    no_gen_iso <- Y$m[ind] # 
    
    plot(x = no_gen_hap, y = no_gen_iso, bty = 'n',
         pch = 20, col = adjustcolor(which(sites == site) + 1, alpha.f = 0.5),
         main = site, 
         xlab = c('hmmIBD'), 
         ylab = c('isoRelate'), 
         xlim = c(0,max(c(no_gen_hap, no_gen_iso))), 
         ylim = c(0,max(c(no_gen_hap, no_gen_iso))))
    points(1,1, pch = 20)
    abline(a = 0, b = 1)
    legend('bottomright', bty = 'n', pch = 20, 
           col = c(adjustcolor(which(sites == site) + 1, alpha.f = 0.5), adjustcolor('black')),
           legend = c('Estimate', 'Simulated truth'), cex = 0.75)
  }
}
```

```{r}
# Define function to plot posterior IBD probability
plot_pos <- function(hmmIBD_output_path){
  
  par(mfrow = c(1,3), pty = 's')
  for(site in sites){
    
    comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
    parent_assignment <- parent_assignment_sites[[site]] 
    
    # hmmIBD
    X <- read.table(sprintf(hmmIBD_output_path, site), header = TRUE)
    haplo_21 <- apply(X[,c('sample2', 'sample1')], 1, paste, collapse = ' ')
    rownames(X) <- haplo_21
    ind <- haplo_21 %in% comparisons_of_interest # all in 21 (not that %in% doesn't conserve order)
    post_prob_hap <- X[ind,][comparisons_of_interest, 'fract_sites_IBD'] # closest thing
    
    # Simulated 
    positive_simulated <- rep(NA, length(comparisons_of_interest))
    names(positive_simulated) <- comparisons_of_interest
    n_snps <- nsnps[site]
    
    for(i in comparisons_of_interest){
      samples <- strsplit(i, ' ')[[1]]
      parent <- sprintf('parent%s', which(strsplit(samples[1], split = ":")[[1]] == samples[2]))
      simulated <- parent_assignment[,strsplit(i, split = ' ')[[1]][1]]
      positive_simulated[i] <- sum(simulated == parent)
    }
    
    plot(x = positive_simulated/n_snps, y = post_prob_hap, bty = 'n',
         pch = 20, col = adjustcolor(which(sites == site) + 1, alpha.f = 0.5),
         xlab = c('Simulated'), 
         ylab = c('hmmIBD'), 
         xlim = c(0,1), 
         ylim = c(0,1))
    
    abline(a = 0, b = 1, lty = 'dotted')
  }
}
```

```{r}
# Load results for inference common across erroneous and non-erroneous children
parent_assignment_sites <- vector('list', length = length(sites))
names(parent_assignment_sites) <- sites

for(site in sites){
  load(sprintf('../pf3k_chimeric_data/parent_assignment_%s.RData', site))
  parent_assignment_sites[[site]] <- parent_assignment
}
```

## Inference based on non-erroneous chimeric children

```{r}
# Load results for non-erroneous chimeric children
comparisons_of_interest_sites <- vector('list', length = length(sites))
isoRelate_assignment_sites <- vector('list', length = length(sites))
hmmIBD_assignment_sites <- vector('list', length = length(sites))
names(comparisons_of_interest_sites) <- sites
names(isoRelate_assignment_sites) <- sites
names(hmmIBD_assignment_sites) <- sites

for(site in sites){
  load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_%s.RData', site))
  load(sprintf('../pf3k_chimeric_data/isoRelate_assignment_%s.RData', site))
  load(sprintf('../pf3k_chimeric_data/hmmIBD_assignment_%s.RData', site))
  comparisons_of_interest_sites[[site]] <- comparisons_of_interest
  isoRelate_assignment_sites[[site]] <- isoRelate_assignment
  hmmIBD_assignment_sites[[site]] <- hmmIBD_assignment
}

# Extract accuracy, specificity and sensitivity
mean_acc_spec_sens <- acc_spec_sens()
attach(mean_acc_spec_sens, warn.conflicts = FALSE)
mean_acc_spec_sens_non_erroneous <- mean_acc_spec_sens # save for summary

# Plot
plot_acc_spec_sens(sites[1])
plot_acc_spec_sens(sites[2])
plot_acc_spec_sens(sites[3])
```

### Illustrative assignment plots for two randomly selected pairwise comparisons from Kassena

```{r}
set.seed(1)
site <- "Kassena"
comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
parent_assignment <- parent_assignment_sites[[site]] 
isoRelate_assignment <- isoRelate_assignment_sites[[site]] 
hmmIBD_assignment <- hmmIBD_assignment_sites[[site]] 
comp1 <- sample(comparisons_of_interest, 1)
plot_assignments(comp1)
comp2 <- sample(comparisons_of_interest, 1)
plot_assignments(comp2)
```


### Estimates of numbers of generations

Both methods overestimate the number of generations:

```{r}
hmmIBD_output_path <- '../pf3k_chimeric_data/hmmIBD_%s.hmm_fract.txt'
isoRelate_output_path <- '../pf3k_chimeric_data/IsoRelate_output_%s.RData'
plot_gen(hmmIBD_output_path, isoRelate_output_path)  
```

### hmmIBD posterior probability of IBD versus proportion simulated IBD 

```{r}
plot_pos(hmmIBD_output_path)
```

## Inference results based on erroneous chimeric children

```{r}
# Load results for non-erroneous chimeric children
comparisons_of_interest_sites <- vector('list', length = length(sites))
isoRelate_assignment_sites <- vector('list', length = length(sites))
hmmIBD_assignment_sites <- vector('list', length = length(sites))
names(comparisons_of_interest_sites) <- sites
names(isoRelate_assignment_sites) <- sites
names(hmmIBD_assignment_sites) <- sites

for(site in sites){
  load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_%s_erroneous.RData', site))
  load(sprintf('../pf3k_chimeric_data/isoRelate_assignment_%s_erroneous.RData', site))
  load(sprintf('../pf3k_chimeric_data/hmmIBD_assignment_%s_erroneous.RData', site))
  comparisons_of_interest_sites[[site]] <- comparisons_of_interest
  isoRelate_assignment_sites[[site]] <- isoRelate_assignment
  hmmIBD_assignment_sites[[site]] <- hmmIBD_assignment
}

# Extract accuracy, specificity and sensitivity
mean_acc_spec_sens <- acc_spec_sens()
attach(mean_acc_spec_sens, warn.conflicts = FALSE)
mean_acc_spec_sens_erroneous <- mean_acc_spec_sens # save for summary

# Plot
plot_acc_spec_sens(sites[1])
plot_acc_spec_sens(sites[2])
plot_acc_spec_sens(sites[3])
```

### Illustrative assignment plots for two randomly selected pairwise comparisons from Kassena

```{r}
set.seed(1)
site <- "Kassena"
comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
parent_assignment <- parent_assignment_sites[[site]] 
isoRelate_assignment <- isoRelate_assignment_sites[[site]] 
hmmIBD_assignment <- hmmIBD_assignment_sites[[site]] 
comp1 <- sample(comparisons_of_interest, 1)
plot_assignments(comp1)
comp2 <- sample(comparisons_of_interest, 1)
plot_assignments(comp2)
```

### Estimates of numbers of generations

Both methods overestimate the number of generations:

```{r}
hmmIBD_output_path <- '../pf3k_chimeric_data/hmmIBD_%s_erroneous.hmm_fract.txt'
isoRelate_output_path <- '../pf3k_chimeric_data/IsoRelate_output_%s_erroneous.RData'
plot_gen(hmmIBD_output_path, isoRelate_output_path)  
```

### hmmIBD posterior probability of IBD versus proportion simulated IBD 

```{r, cache.comments = FALSE, echo = FALSE}
plot_pos(hmmIBD_output_path)
```

# Summary

Both isoRelate and hmmIBD are highly accurate, sensitive and specific, including when genotyping error equal to 0.005 in the data is misspecified under the model at 0.001. In addition to IBD segments, hmmIBD returns the posterior IBD proportion (a measure of relatedness that integrates over all possible IBD segment assignments). Under v0.1.0 of isoRelate, posterior probabilities of the IBD state are not readily accessible, but many auxiliary functions for visualizing model output and assessing significance are provided. On average, hmmIBD was `r round(fold_diff, 0)` times faster in user CPU time than isoRelate, but both perform adequately in real time.   

```{r}
summary_times <- cbind('Clock time (sec)' = c(sprintf('%s (%s)', round(mean_times_real,
                                                                       3)['isoRelate'],round(se_real['isoRelate'], 3)), 
                                              sprintf('%s (%s)', round(mean_times_real,
                                                                       3)['hmmIBD'],round(se_real['hmmIBD'], 3))),
                       'CPU time (sec)' = c(sprintf('%s (%s)', round(mean_times_user,
                                                                     3)['isoRelate'],round(se_user['isoRelate'], 3)), 
                                            sprintf('%s (%s)', round(mean_times_user,
                                                                     3)['hmmIBD'],round(se_user['hmmIBD'], 3))))

rownames(summary_times) <- c('isoRelate', 'hmmIBD') 
kable(summary_times, caption = sprintf('Summary of average run times for %s samples on a MacBook Air with 1.7 GHz Intel Core i7 processor. Standard deviations in parentheses.', n_timing_samples_to_run))
```


```{r}
attach(mean_acc_spec_sens_non_erroneous, warn.conflicts = F) 
summary_table <- cbind('Accuracy' = c(sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['isoRelate'],
                                              round(apply(accuracy, 2, sd), 3)['isoRelate']), 
                                      sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['hmmIBD'],
                                              round(apply(accuracy, 2, sd), 3)['hmmIBD'])), 
                       'Sensitivity' = c(sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['isoRelate'],
                                                 round(apply(sensitivity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(sensitivity, 2, sd), 3)['hmmIBD'])), 
                       
                       'Specificity' = c(sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['isoRelate'],
                                                 round(apply(specificity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(specificity, 2, sd), 3)['hmmIBD'])))

rownames(summary_table) <- c('isoRelate', 'hmmIBD') 
kable(summary_table, caption = 'Summary of average scores based on non-erroneous data with standard deviations in parentheses.')
```

```{r}
attach(mean_acc_spec_sens_erroneous, warn.conflicts = F) 
summary_table <- cbind('Accuracy' = c(sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['isoRelate'],
                                              round(apply(accuracy, 2, sd), 3)['isoRelate']), 
                                      sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['hmmIBD'],
                                              round(apply(accuracy, 2, sd), 3)['hmmIBD'])), 
                       'Sensitivity' = c(sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['isoRelate'],
                                                 round(apply(sensitivity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(sensitivity, 2, sd), 3)['hmmIBD'])), 
                       
                       'Specificity' = c(sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['isoRelate'],
                                                 round(apply(specificity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(specificity, 2, sd), 3)['hmmIBD'])))

rownames(summary_table) <- c('isoRelate', 'hmmIBD') 
kable(summary_table, caption = sprintf('Summary of average scores based on erroneous data with standard deviations in parentheses.', n_timing_samples_to_run))
```
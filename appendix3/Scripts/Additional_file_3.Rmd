---
title: 'Additional file 3: Comparative study of isoRelate and hmmIBD and impact of assumed uniform recombination under hmmIBD'
output: pdf_document
---

# Comparative study of isoRelate and hmmIBD

## Methods

### Summary of files and variables used

The following section summarizes results generated from a comparative study of hmmIBD and isoRelate (Henden L, et al. BioRxiv. 2016). Analyses were based on data generated by artificial recombination (details below). The steps, data and scripts required to reproduce this study are as follows.

1. Download the hmmIBD_benchmark repository from https://github.com/artaylor85/hmmIBD_benchmark and unzip the pf3k_data directory.
2. Install hmmIBD following instructions at https://github.com/glipsnort/hmmIBD/releases (v2.0.0).
3. Install isoRelate following instructions at https://github.com/bahlolab/isoRelate/releases (results here based on v0.1.0 installed Aug 9th 2017).
4. Set working directory to this source file location.
5. Run $\texttt{Simulate\_chimeric\_genotypes.R}$.
6. Run $\texttt{Run\_isolate\_hmmIBD.R}$.
7. Run $\texttt{Post\_process\_results.R}$.
8. Run/knit the Rmd file that generates Additional_file_3.pdf (i.e. this file).

Once downloaded, the code in $\texttt{hmmIBD\_benchmark}$ can be modified in any way (e.g. to explore data from sites with fewer than 100 isolates, edit $\texttt{min\_num = 100}$ in $\texttt{Simulate\_chimeric\_genotypes.R}$).

```{r setup, include=FALSE}
#===============================================================================
# Default chunk options
#===============================================================================
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, include=TRUE, cache=TRUE, cache.comments = FALSE, fig.pos = 'H', fig.width = 7, dev = 'png', dpi = 300)

# Clear workspace, load libraries, specify magic numbers used
rm(list = ls()) 
inst_pkg_list <- rownames(installed.packages())
if("knitr" %in% inst_pkg_list){# For tables from matrices
  library(knitr) 
} else {
  install.packages("knitr")
  library(knitr)
}

# Magic numbers
load(file = '../pf3k_chimeric_data/Run_isoRelate_hmmIBD_magic_numbers.RData')
attach(Magic_numbers)
load(file = '../pf3k_chimeric_data/Simulate_chimeric_genotypes_Magic_numbers.RData')
attach(Magic_numbers)
rho <- as.character(signif(rho,3))

# Numbers of SNPs
load('../pf3k_chimeric_data/sites.RData')
nsnps <- rep(NA,3)
names(nsnps) <- sites
for(site in sites){
  load(sprintf('../pf3k_chimeric_data/parent_assignment_%s.RData', site))
  nsnps[site] <- nrow(parent_assignment)
  rm(parent_assignment)
}
```


### Simulation of artificially recombined data 

We used artificially recombined data to compare results generated under hmmIBD and isoRelate to a known truth that was not generated under either model. Artificially recombined data were based on the MalariaGen Pf3k samples, pilot release 5.0 (https://www.malariagen.net/projects/pf3k). These data were filtered prior to their use in this comparative study, leaving only single nucleotide polymorphisms (SNPs) in the accessible genome (as defined by Miles A, et al. Genome Research. 2016), and those with a high probability of being monogenomic (as defined by DEploid from Zhu SJ, Almagro-garcia J, Mcvean G. BioRxiv. 2017). The filtered data can be found in $\texttt{pf3k\_data}$. Using $\texttt{Simulate\_chimeric\_genotypes.R}$ we:

1.  Extracted samples from sites with `r min_num` or more samples (Thies, Kassena, Pursat). 
2.  For each site, removed multiallelic SNPs (unsupported by isoRelate) and those with minor allele frequency $\leq$ `r MAF`, leaving `r nsnps` SNPs per sample from `r names(nsnps)`, respectively. 
3.  Calculated and saved allele frequencies and data sets based on the unrecombined data to ensure frequencies were not based on chimeric samples.
4.  For each pairwise comparison within a site, calculated the average identity-by-state, IBS (one minus the genome-wide average SNP difference), and plotted. 
5.  Extracted unrelated pairs (those with IBS < `r cutoff*100` percentile of the empirical IBS distribution). 
6.  Artificially recombined each unrelated sample pair to create a "chimeric child". Recombination was simulated by sampling crossover positions (in base pairs, bp) from an exponential distribution with mean equal to the recombination rate in Morgans, M, per bp (see $\texttt{functions.R}$). 
7. Recorded the parent of each DNA segment in each chimeric child, and plotted the number of crossovers per chromosome averaged over all the chimeric children per site.  

In addition to the above steps, we generated an erroneous copy of each parent and chimeric child. More specifically, for each SNP with probability equal to the genotyping error `r error_prob`, the copied allele was replaced by its biallelic counterpart. 

<!-- MAKE SURE THIS THIS SECTION IS CONSISTENT WITH PARAMETERS USED IN hmm.c -->

### Experiments to evaluate timing 

Timing experiments were performed on the first `r n_timing_samples_to_run` samples per site (including unrecombined parents and non-erroneous chimeric children), and repeated `r n_timing_repetition` times on a MacBook Air laptop with 1.7 GHz Intel Core i7 processor using the parameter values listed in the table below. Some of the parameter values differ to the defaults provided in order to more closely match the two methods.  

Parameter |  isoRelate | hmmIBD
---------------------------------------------------------------- | ----------  | ----------
genotyping error | 0.001  | 0.001
recombination rate | `r rho` M/bp$\dagger$ | `r rho` M/bp
minimum no. SNPs per segment | `r min_snps` | NA
minimum length (bp) per segment | `r minimum_length_bp` | NA
Minimum marker spacing (bp) | NA | 0
Minimum informative sites per genome | NA | 0  

Table: Specified parameter values. NA denotes not applicable. $\dagger$In isoRelate, the "recombination rate" is a function of distance in M. The equivalent fixed rate in M/bp in hmmIBD was thus based on the empirical relationship between positions in bp and centimorgans provided in the png_pedmap data set of the isoRelate package. 


### Experiments to evaluate inference 

For each site, IBD segments between `r n_children_to_analyse` "chimeric children" and each of their two parents were inferred under isoRelate and hmmIBD using the parameter values listed in the table above. Accuracy, sensitivity and specificity were calculated as follows, where for a given pairwise comparison and SNP, a true positive is an IBD observation given an IBD state, and a true negative is a not IBD (nIBD) observation given a nIBD state,  

\begin{align}
\text{Accuracy} &= \dfrac{\sum \text{ True positive} + \sum \text{ True negative}}{\text{Number of SNPs}},\\
\text{Sensitivity} &= \dfrac{\sum \text{ True positive}}{\sum \text{ IBD states}},\\
\text{Specificity} &= \dfrac{\sum \text{ True negative}}{\sum \text{ nIBD states}}.
\end{align}

We also compared estimates of the numbers of generations inferred under isoRelate and hmmIBD, and the proportion simulated IBD with the posterior probability of IBD inferred under hmmIBD (the latter was not directly available under v0.1.0 of isoRelate).

To investigate the impact of genotyping error, the entire process was then repeated for the erroneous copies of `r n_children_to_analyse` chimeric children and their parents. We expect error to introduce small and incorrectly inferred segments into otherwise correctly inferred segments of DNA that are both IBD and not. Concomitantly, we expect error to spuriously increase estimates of numbers of generations since most recent common ancestors. 

## Results

### Timing 

```{r} 
time_store <- array(dim = c(length(sites)*n_timing_repetition,2,2), 
                    dimnames = list(paste(sites, rep(1:n_timing_repetition, each = length(sites))), c('isoRelate', 'hmmIBD'), c('real', 'user')))

# hmmIBD
load('../pf3k_chimeric_data/hmmIBD_timing_output.RData')

for(site in sites){
  for(i in 1:n_timing_repetition){
    
    # IsoRelate
    load(sprintf('../pf3k_chimeric_data/IsoRelate_timing_output_%s_%s.RData', site, i))
    
    # Extract
    time_store[paste(site, i), 'isoRelate', 'real'] <- results$time_my_ibd['elapsed']
    time_store[paste(site, i), 'hmmIBD', 'real'] <- time_my_ibd[[paste(site, i)]]['elapsed'] 
    time_store[paste(site, i), 'isoRelate', 'user'] <- results$time_my_ibd['user.child'] + results$time_my_ibd['user.self']
    time_store[paste(site, i), 'hmmIBD', 'user'] <- time_my_ibd[[paste(site, i)]]['user.child'] + time_my_ibd[[paste(site, i)]]['user.self']
  }
}

# Visually report times
kable(time_store[,,'real'], caption = sprintf('Clocktime (sec) per %s samples', n_timing_samples_to_run))

kable(time_store[,,'user'], caption = sprintf('CPU time (sec) per %s samples', n_timing_samples_to_run))

# Report average time (with CIs or range) 
mean_times_real <- colMeans(time_store[,,'real'])
mean_times_user <- colMeans(time_store[,,'user'])

# Standard deviations
se_real <- apply(time_store[,,'real'], 2, sd)
se_user <- apply(time_store[,,'user'], 2, sd)

# Average fold difference
fold_diff <- mean(time_store[,'isoRelate','user']/time_store[,'hmmIBD','user'])
```


```{r, cache.comments = FALSE, echo = FALSE}
# Define function to plot asignments
plot_assignments <- function(comp, hmmIBD = TRUE, isoRelate = TRUE){
  
  # Determine if a comparison with parent1 or parent2? 
  samples <- strsplit(comp, split = ' ')[[1]]
  child_ind <- grepl(":", samples)
  child <- samples[child_ind]
  parent <- sprintf('parent%s', which(strsplit(child, split = ":" )[[1]] == samples[!child_ind]))
  
  # Exract and colour assignment
  sim <- parent_assignment[,child]
  parentcol <- c(parent1 = 'blue', parent2 = 'pink')
  sim[sim == 'parent1'] <- parentcol['parent1']
  sim[sim == 'parent2'] <- parentcol['parent2']
  
  if(hmmIBD){
    hap <- hmmIBD_assignment[,comp]
    hap[hap == parent] <- parentcol[parent]
    hap[hap == 'DBD'] <- 'gray'
    hap[is.na(hap)] <- 'black'
  }
  
  if(isoRelate){
    iso <- isoRelate_assignment[,comp]
    iso[iso == parent] <- parentcol[parent]
    iso[iso == 'DBD'] <- 'gray'
    iso[is.na(iso)] <- 'black'  
  }
  
  
  # Get chromosome lengths
  chr_length <- read.csv(file = '../pf3k_data/Pf_v3_chrom_length.csv', 
                         skip = 2, header = FALSE)[,'V3']
  
  # Plot set up 
  if(hmmIBD & isoRelate){par(mfrow = c(3,1), mar = c(1,1,1,1))}
  if(hmmIBD | isoRelate){par(mfrow = c(2,1), mar = c(1,1,1,1))}
  
  # Simulated
  barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
  title(main = 'Simulated')
  legend('bottomright', legend = c('SNP inherited from parent1', 'SNP inherited from parent2'), 
         bty = 'n', 
         col = c(parentcol['parent1'], parentcol['parent2']), lty = 1, lwd = 2, inset = 0.15)
  for(chr in 1:14){
    indices <- which(parent_assignment[,'chrom'] == chr)
    for(ind in indices){
      segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
               x0 = parent_assignment$pos[ind], 
               x1 = parent_assignment$pos[ind], 
               col = sim[ind]) 
    }
  }
  
  # Inferred isoRelate
  if(isoRelate){
    barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
    title(main = 'Inferred under isoRelate')
    legend('bottomright', legend = c(sprintf('SNP IBD with %s', parent), 
                                     sprintf('SNP nIBD with %s', parent), 'NA'), bty = 'n', 
           col = c(parentcol[parent], 'gray', 'black'), lty = 1, lwd = 2, inset = 0.15)
    for(chr in 1:14){
      indices <- which(parent_assignment$chrom == chr)
      for(ind in indices){
        segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
                 x0 = parent_assignment$pos[ind], 
                 x1 = parent_assignment$pos[ind], 
                 col = iso[ind]) 
      }
    }  
  }
  
  
  # Inferred hmmIBD
  if(hmmIBD){
    barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
    title(main = 'Inferred under hmmIBD')
    legend('bottomright', legend = c(sprintf('SNP IBD with %s', parent), 
                                     sprintf('SNP nIBD with %s', parent), 'NA'), bty = 'n', 
           col = c(parentcol[parent], 'gray', 'black'), lty = 1, lwd = 2, inset = 0.15)  
    for(chr in 1:14){
      indices <- which(parent_assignment$chrom == chr)
      for(ind in indices){
        segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
                 x0 = parent_assignment$pos[ind], 
                 x1 = parent_assignment$pos[ind], 
                 col = hap[ind]) 
      }
    }   
  }
}
```


```{r}
# Define function to extract accuracy, specificity and sensitivity
acc_spec_sens <- function(hmmIBD = TRUE, isoRelate = TRUE){
  
  # Accuracy, sensitivity and specificity stores 
  accuracy <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), 
                    dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))
  sensitivity <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), 
                       dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))
  specificity <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), 
                       dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))
  
  for(site in sites){
    
    comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
    parent_assignment <- parent_assignment_sites[[site]] 
    if(isoRelate){isoRelate_assignment <- isoRelate_assignment_sites[[site]]} 
    if(hmmIBD){hmmIBD_assignment <- hmmIBD_assignment_sites[[site]]}
    
    n_snps <- nsnps[site]
    
    for(i in 1:length(comparisons_of_interest)){
      
      # Extract parent of comparison
      samples <- strsplit(comparisons_of_interest[i], ' ')[[1]]
      parent <- sprintf('parent%s', which(strsplit(samples[1], split = ":")[[1]] == samples[2]))
      simulated <- parent_assignment[,strsplit(comparisons_of_interest[i], split = ' ')[[1]][1]]
      positive_simulated <- sum(simulated == parent)
      negative_simulated <- sum(simulated != parent)
      
      # Calculate accuracy isoRelate (not counting NAs)
      if(isoRelate){
        inferred_iso <- isoRelate_assignment[,comparisons_of_interest[i]]
        true_positive_iso <- sum(simulated == inferred_iso, na.rm = TRUE)
        true_negative_iso <- sum((simulated != parent) & (inferred_iso == 'DBD'), na.rm = TRUE) 
        accuracy[i, 'isoRelate', site] <- (true_positive_iso + true_negative_iso)/n_snps  
      }
      
      # Calculate accuracy hmmIBD (not counting NAs)
      if(hmmIBD){
        inferred_hap <- hmmIBD_assignment[,comparisons_of_interest[i]]
        true_positive_hap <- sum(simulated == inferred_hap, na.rm = TRUE)
        true_negative_hap <- sum((simulated != parent) & (inferred_hap == 'DBD'), na.rm = TRUE) 
        accuracy[i, 'hmmIBD', site] <- (true_positive_hap + true_negative_hap)/n_snps  
      }
      
      # Calculate Sensitivity and specificity
      if(isoRelate){  
        sensitivity[i, 'isoRelate', site] <- true_positive_iso/positive_simulated
        specificity[i, 'isoRelate', site] <- true_negative_iso/negative_simulated
      }
      if(hmmIBD){
        sensitivity[i, 'hmmIBD', site] <- true_positive_hap/positive_simulated
        specificity[i, 'hmmIBD', site] <- true_negative_hap/negative_simulated
      }
    }
  }
  
  # Summarise for plots below
  mean_accuracy <- apply(accuracy, c(2,3), mean) 
  mean_sensitivity <- apply(sensitivity, c(2,3), mean) 
  mean_specificity <- apply(specificity, c(2,3), mean) 
  
  acc_spec_sens_list <- list(mean_accuracy = mean_accuracy, 
                             mean_sensitivity = mean_sensitivity, 
                             mean_specificity = mean_specificity, 
                             accuracy = accuracy, 
                             sensitivity = sensitivity, 
                             specificity = specificity)
  
  return(acc_spec_sens_list)
} 
```


```{r}
# Define function to plot accuracy, specificity and sensitivity
plot_acc_spec_sens <- function(site, hmmIBD = TRUE, isoRelate = TRUE){
  
  plot(NULL, ylim = c(0,1), xlim = c(0,1), bty = 'n', main = site, 
       xlab = 'False positive rate (1-specificity)', 
       ylab = 'True positive rate (sensitivity)')
  
  if(hmmIBD & isoRelate){
    title(sub = sprintf('Mean accuracy %s (isoRelate) %s (hmmIBD)',
                        round(mean_accuracy[,site],4)['isoRelate'],
                        round(mean_accuracy[,site],4)['hmmIBD'])) 
    legend('right',  
           col = c('darkgreen', 'blue', 'darkgreen', 'blue'), pch = c(20, 20, NA, NA), 
           pt.cex =  c(1, 1, 0, 0), lty = c(0, 0, 2, 2), bty = 'n', cex = 0.8, 
           legend = c('isoRelate single comparison', 'hmmIBD single comparison', 
                      'isoRelate mean', 'hmmIBD mean'))
  } else {
    if(hmmIBD){
      title(sub = sprintf('Mean accuracy %s (hmmIBD)', round(mean_accuracy[,site],4)['hmmIBD']))
      legend('right',  col = 'blue', pch = c(20, NA), pt.cex =  c(1, 0), lty = c(0, 2), bty = 'n', cex = 0.8, 
             legend = c('hmmIBD single comparison', 'hmmIBD mean'))
    }
    if(isoRelate){
      title(sub = sprintf('Mean accuracy %s (isoRelate)',round(mean_accuracy[,site],4)['isoRelate']))
      legend('right',  col = 'darkgreen', pch = c(20, NA), pt.cex =  c(1, 0), lty = c(0, 2), bty = 'n', cex = 0.8, 
             legend = c('isoRelate single comparison', 'isoRelate mean'))
    }
  }
  
  if(isoRelate){
    points(y = sensitivity[, 'isoRelate', site], x = (1-specificity[, 'isoRelate', site]), 
           col = adjustcolor('darkgreen', alpha.f = 0.5), pch = 20)
    abline(h = mean_sensitivity['isoRelate', site], 
           v = 1-mean_specificity['isoRelate', site], col = 'darkgreen', lty = 'dashed')  
  }
  
  if(hmmIBD){
    points(y = sensitivity[, 'hmmIBD', site], x = (1-specificity[, 'hmmIBD', site]), 
           col = adjustcolor('blue', alpha.f = 0.5), pch = 20)
    abline(h = mean_sensitivity['hmmIBD', site], 
           v = 1-mean_specificity['hmmIBD', site], col = 'blue', lty = 'dashed')
  }
}
```


```{r}
# Define function to plot generations
plot_gen <- function(hmmIBD_output_path, IsoRelate_output_path){
  par(mfrow = c(1,3), pty = 's')
  for(site in sites){
    
    comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
    
    # hmmIBD
    X <- read.table(sprintf(hmmIBD_output_path, site), header = TRUE)
    haplo_21 <- apply(X[,c('sample2', 'sample1')], 1, paste, collapse = ' ')
    ind <- haplo_21 %in% comparisons_of_interest
    no_gen_hap <- X$N_generation[ind]
    
    # isoRelate (ind as above since assignments have the same dimnames)
    load(sprintf(isoRelate_output_path, site))
    Y <- results$my_parameters
    haplo_21 <- apply(Y[,c('iid2', 'iid1')], 1, paste, collapse = ' ')
    ind <- haplo_21 %in% comparisons_of_interest # all in 21 (ordering)
    no_gen_iso <- Y$m[ind] 
    
    plot(x = no_gen_hap, y = no_gen_iso, bty = 'n',
         pch = 20, col = adjustcolor(which(sites == site) + 1, alpha.f = 0.5),
         main = site, 
         xlab = c('hmmIBD'), 
         ylab = c('isoRelate'), 
         xlim = c(0,max(c(no_gen_hap, no_gen_iso))), 
         ylim = c(0,max(c(no_gen_hap, no_gen_iso))))
    points(1,1, pch = 20)
    abline(a = 0, b = 1)
    legend('bottomright', bty = 'n', pch = 20, 
           col = c(adjustcolor(which(sites == site) + 1, alpha.f = 0.5), adjustcolor('black')),
           legend = c('Estimate', 'Simulated truth'), cex = 0.75)
  }
}
```


```{r}
# Define function to plot posterior IBD probability
plot_pos <- function(hmmIBD_output_path){
  
  par(mfrow = c(1,3), pty = 's')
  for(site in sites){
    
    comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
    parent_assignment <- parent_assignment_sites[[site]] 
    
    # hmmIBD
    X <- read.table(sprintf(hmmIBD_output_path, site), header = TRUE)
    haplo_21 <- apply(X[,c('sample2', 'sample1')], 1, paste, collapse = ' ')
    rownames(X) <- haplo_21
    ind <- haplo_21 %in% comparisons_of_interest # all in 21 (not that %in% doesn't conserve order)
    post_prob_hap <- X[ind,][comparisons_of_interest, 'fract_sites_IBD'] # closest thing
    
    # Simulated 
    positive_simulated <- rep(NA, length(comparisons_of_interest))
    names(positive_simulated) <- comparisons_of_interest
    n_snps <- nsnps[site]
    
    for(i in comparisons_of_interest){
      samples <- strsplit(i, ' ')[[1]]
      parent <- sprintf('parent%s', which(strsplit(samples[1], split = ":")[[1]] == samples[2]))
      simulated <- parent_assignment[,strsplit(i, split = ' ')[[1]][1]]
      positive_simulated[i] <- sum(simulated == parent)
    }
    
    plot(x = positive_simulated/n_snps, y = post_prob_hap, bty = 'n',
         pch = 20, col = adjustcolor(which(sites == site) + 1, alpha.f = 0.5),
         xlab = c('Simulated'), 
         ylab = c('hmmIBD'), 
         xlim = c(0,1), 
         ylim = c(0,1), 
         main = site)
    
    abline(a = 0, b = 1, lty = 'dotted')
  }
}
```


```{r}
# Load results for inference common across erroneous and non-erroneous children
parent_assignment_sites <- vector('list', length = length(sites))
names(parent_assignment_sites) <- sites

for(site in sites){
  load(sprintf('../pf3k_chimeric_data/parent_assignment_%s.RData', site))
  parent_assignment_sites[[site]] <- parent_assignment
}
```


### Inference based on non-erroneous chimeric children

```{r}
# Load results for non-erroneous chimeric children
comparisons_of_interest_sites <- vector('list', length = length(sites))
isoRelate_assignment_sites <- vector('list', length = length(sites))
hmmIBD_assignment_sites <- vector('list', length = length(sites))
names(comparisons_of_interest_sites) <- sites
names(isoRelate_assignment_sites) <- sites
names(hmmIBD_assignment_sites) <- sites

for(site in sites){
  load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_%s.RData', site))
  load(sprintf('../pf3k_chimeric_data/isoRelate_assignment_%s.RData', site))
  load(sprintf('../pf3k_chimeric_data/hmmIBD_assignment_%s.RData', site))
  comparisons_of_interest_sites[[site]] <- comparisons_of_interest
  isoRelate_assignment_sites[[site]] <- isoRelate_assignment
  hmmIBD_assignment_sites[[site]] <- hmmIBD_assignment
}

# Extract accuracy, specificity and sensitivity
mean_acc_spec_sens <- acc_spec_sens()
attach(mean_acc_spec_sens, warn.conflicts = FALSE)
mean_acc_spec_sens_non_erroneous <- mean_acc_spec_sens # save for summary

# Plot
plot_acc_spec_sens(sites[1])
plot_acc_spec_sens(sites[2])
plot_acc_spec_sens(sites[3])
```

\pagebreak

#### Illustrative assignment plots for two randomly selected pairwise comparisons based on non-erroneous chimeric children from Kassena.

```{r}
set.seed(1)
site <- "Kassena"
comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
parent_assignment <- parent_assignment_sites[[site]] 
isoRelate_assignment <- isoRelate_assignment_sites[[site]] 
hmmIBD_assignment <- hmmIBD_assignment_sites[[site]] 
comp1 <- sample(comparisons_of_interest, 1)
plot_assignments(comp1)
comp2 <- sample(comparisons_of_interest, 1)
plot_assignments(comp2)
```

\pagebreak

#### Numbers of generations based on non-erroneous chimeric children

Both methods overestimate the number of generations.

```{r, fig.height=3}
hmmIBD_output_path <- '../pf3k_chimeric_data/hmmIBD_%s.hmm_fract.txt'
isoRelate_output_path <- '../pf3k_chimeric_data/IsoRelate_output_%s.RData'
plot_gen(hmmIBD_output_path, isoRelate_output_path)  
```

#### Posterior probabilities of the IBD state versus proportion simulated IBD based on non-erroneous chimeric children.

```{r, fig.height=3}
plot_pos(hmmIBD_output_path)
```

### Inference results based on erroneous chimeric children

```{r}
# Load results for non-erroneous chimeric children
comparisons_of_interest_sites <- vector('list', length = length(sites))
isoRelate_assignment_sites <- vector('list', length = length(sites))
hmmIBD_assignment_sites <- vector('list', length = length(sites))
names(comparisons_of_interest_sites) <- sites
names(isoRelate_assignment_sites) <- sites
names(hmmIBD_assignment_sites) <- sites

for(site in sites){
  load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_%s_erroneous.RData', site))
  load(sprintf('../pf3k_chimeric_data/isoRelate_assignment_%s_erroneous.RData', site))
  load(sprintf('../pf3k_chimeric_data/hmmIBD_assignment_%s_erroneous.RData', site))
  comparisons_of_interest_sites[[site]] <- comparisons_of_interest
  isoRelate_assignment_sites[[site]] <- isoRelate_assignment
  hmmIBD_assignment_sites[[site]] <- hmmIBD_assignment
}

# Extract accuracy, specificity and sensitivity
mean_acc_spec_sens <- acc_spec_sens()
attach(mean_acc_spec_sens, warn.conflicts = FALSE)
mean_acc_spec_sens_erroneous <- mean_acc_spec_sens # save for summary

# Plot
plot_acc_spec_sens(sites[1])
plot_acc_spec_sens(sites[2])
plot_acc_spec_sens(sites[3])
```

\pagebreak

#### Illustrative assignment plots for two randomly selected pairwise comparisons based on erroneous chimeric children from Pursat.

```{r}
set.seed(1)
site <- "Pursat"
comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
parent_assignment <- parent_assignment_sites[[site]] 
isoRelate_assignment <- isoRelate_assignment_sites[[site]] 
hmmIBD_assignment <- hmmIBD_assignment_sites[[site]] 
comp1 <- sample(comparisons_of_interest, 1)
plot_assignments(comp1)
comp2 <- sample(comparisons_of_interest, 1)
plot_assignments(comp2)
```

\pagebreak

#### Numbers of generations based on erroneous chimeric children.

Both methods overestimate the number of generations.

```{r, fig.height=3}
hmmIBD_output_path <- '../pf3k_chimeric_data/hmmIBD_%s_erroneous.hmm_fract.txt'
isoRelate_output_path <- '../pf3k_chimeric_data/IsoRelate_output_%s_erroneous.RData'
plot_gen(hmmIBD_output_path, isoRelate_output_path)  
```

#### Posterior probabilities of the IBD state versus proportion simulated IBD based on erroneous chimeric children.

```{r, fig.height=3}
plot_pos(hmmIBD_output_path)
```

## Summary

Both isoRelate and hmmIBD are highly accurate, sensitive and specific, including when genotyping error equal to 0.005 in the data is misspecified under the model at 0.001. In addition to IBD segments, hmmIBD returns the posterior IBD proportion (a measure of relatedness that integrates over all possible IBD segment assignments). Under v0.1.0 of isoRelate, posterior probabilities of the IBD state are not readily accessible, but many auxiliary functions for visualizing model output and assessing significance are provided. On average, hmmIBD was $`r round(fold_diff, 0)`$ times faster in user CPU time than isoRelate, but both perform adequately in real time.

```{r}
summary_times <- cbind('Clock time (sec)' = c(sprintf('%s (%s)', round(mean_times_real,
                                                                       3)['isoRelate'],round(se_real['isoRelate'], 3)), 
                                              sprintf('%s (%s)', round(mean_times_real,
                                                                       3)['hmmIBD'],round(se_real['hmmIBD'], 3))),
                       'CPU time (sec)' = c(sprintf('%s (%s)', round(mean_times_user,
                                                                     3)['isoRelate'],round(se_user['isoRelate'], 3)), 
                                            sprintf('%s (%s)', round(mean_times_user,
                                                                     3)['hmmIBD'],round(se_user['hmmIBD'], 3))))

rownames(summary_times) <- c('isoRelate', 'hmmIBD') 
kable(summary_times, caption = sprintf('Summary of average run times for %s samples on a MacBook Air with 1.7 GHz Intel Core i7 processor. Standard deviations in parentheses.', n_timing_samples_to_run))
```


```{r}
attach(mean_acc_spec_sens_non_erroneous, warn.conflicts = F) 
summary_table <- cbind('Accuracy' = c(sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['isoRelate'],
                                              round(apply(accuracy, 2, sd), 3)['isoRelate']), 
                                      sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['hmmIBD'],
                                              round(apply(accuracy, 2, sd), 3)['hmmIBD'])), 
                       'Sensitivity' = c(sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['isoRelate'],
                                                 round(apply(sensitivity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(sensitivity, 2, sd), 3)['hmmIBD'])), 
                       
                       'Specificity' = c(sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['isoRelate'],
                                                 round(apply(specificity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(specificity, 2, sd), 3)['hmmIBD'])))

rownames(summary_table) <- c('isoRelate', 'hmmIBD') 
kable(summary_table, caption = 'Summary of average scores based on non-erroneous data with standard deviations in parentheses.')
```


```{r}
attach(mean_acc_spec_sens_erroneous, warn.conflicts = F) 
summary_table <- cbind('Accuracy' = c(sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['isoRelate'],
                                              round(apply(accuracy, 2, sd), 3)['isoRelate']), 
                                      sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['hmmIBD'],
                                              round(apply(accuracy, 2, sd), 3)['hmmIBD'])), 
                       'Sensitivity' = c(sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['isoRelate'],
                                                 round(apply(sensitivity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(sensitivity, 2, sd), 3)['hmmIBD'])), 
                       
                       'Specificity' = c(sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['isoRelate'],
                                                 round(apply(specificity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(specificity, 2, sd), 3)['hmmIBD'])))

rownames(summary_table) <- c('isoRelate', 'hmmIBD') 
kable(summary_table, caption = sprintf('Summary of average scores based on erroneous data with standard deviations in parentheses.', n_timing_samples_to_run))
```

# Impact of assuming uniform recombination under hmmIBD

To explore the impact of a misspecified uniform recombination rate under hmmIBD, we analysed data generated using a non-uniform recombination rate under hmmIBD (v2.0.0) with the default uniform recombination rate of 7.4-7 M/bp (based on the average reported in Miles A, et al. Genome Research. 2016). The data were generated alongside the data used in the comparative study as described above with the following exception. Recombination was simulated by sampling crossover events per base pair position, $x$, from a Bernoulli distribution with probability equal to recombination rate, $\rho(x)$, based on the following piecewise constant function (see functions.R),

\begin{equation}
\rho(x) =
\begin{cases}
3 \times 10^{-7} \text{M/bp if } x \text{ is within 30 kb of the start or end position of the centromere} \\
11.5 \times 10^{-7} \text{M/bp if } x \text{ is within 80-120 kb of the start or end position of the centromere} \\
7.4 \times 10^{-7} \text{M/bp otherwise. }
\end{cases} \label{eq: piecewise rho}
\end{equation}

where the start and end positions of the centromeres are based on Table S2 of Miles A, et al. Genome Research. 2016. Equation \eqref{eq: piecewise rho} is based on findings reported in Miles A, et al. Genome Research. 2016. Specifically, Miles et al. found that within approximately 30 kb of the centromere, the recombination rate was significantly lower than average; and that between approximately 80 and 120 kb of the centromere, the rate was slightly higher than average. Based on Figure 3C of Miles A, et al. Genome Research. 2016., the lower rate is approximately equal to 0.3 M/Mbp ($3 \times 10^{-7}$ M/bp), the slightly higher rate is approximately equal to 1.15 M/Mbp ($11.5 \times 10^{-7}$ M/bp), while the average rate is equal to 0.74 M/Mbp ($7.4 \times 10^{-7}$ M/bp).

As above, accuracy, sensitivity and specificity were high (Table \ref{tab: nonuniform} and Figures \ref{fig: acc_spec_sens nonuniform} and \ref{fig: assignment nonuniform}); hmmIBD overestimated the number of generations (Figure \ref{fig: no. gen nonuniform}), but posterior probabilities closely matched the proportion simulated IBD (Figure \ref{fig: post prob nonuniform}).

In summary, given deviations within a biologically informed range (Miles A, et al. Genome Research. 2016.), the assumption of uniform recombination has little impact upon inference on IBD under hmmIBD using data within the accessible genome. The assumption is unlikely to hold over regions where the recombination rate deviates greatly from the average over the accessible genome, however. We therefore recommend exclusion of such regions (e.g. subtelomeric regions) in data analysed under hmmIBD.

```{r}
# Load results for inference common across nonuniform chimeric children
parent_assignment_sites <- vector('list', length = length(sites))
names(parent_assignment_sites) <- sites
for(site in sites){
  load(sprintf('../pf3k_chimeric_data/parent_assignment_nonuniform_%s.RData', site))
  parent_assignment_sites[[site]] <- parent_assignment_nonuniform
}

# Load results for nonuniform chimeric children
comparisons_of_interest_sites <- vector('list', length = length(sites))
hmmIBD_assignment_sites <- vector('list', length = length(sites))
names(comparisons_of_interest_sites) <- sites
names(hmmIBD_assignment_sites) <- sites

for(site in sites){
  load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_nonuniform_%s.RData', site))
  load(sprintf('../pf3k_chimeric_data/hmmIBD_assignment_nonuniform_%s.RData', site))
  comparisons_of_interest_sites[[site]] <- comparisons_of_interest
  hmmIBD_assignment_sites[[site]] <- hmmIBD_assignment
}

# Extract accuracy, specificity and sensitivity
Z <- acc_spec_sens(hmmIBD = TRUE, isoRelate = FALSE)
```


```{r}
summary_table <- cbind('Accuracy' = c(sprintf('%s (%s)', 
                                              round(colMeans(Z$accuracy[,'hmmIBD',]), 3),
                                              round(apply(Z$accuracy[,'hmmIBD',], 2, sd), 3))), 
                       'Sensitivity' = c( sprintf('%s (%s)', 
                                                 round(colMeans(Z$sensitivity[,'hmmIBD',]), 3),
                                                 round(apply(Z$sensitivity[,'hmmIBD',], 2, sd), 3))), 
                       'Specificity' = c(sprintf('%s (%s)', 
                                                 round(colMeans(Z$specificity[,'hmmIBD',]), 3),
                                                 round(apply(Z$specificity[,'hmmIBD',], 2, sd), 3))))

rownames(summary_table) <- dimnames(Z$mean_accuracy)[[2]]
kable(summary_table, caption = '\\label{tab: nonuniform} Summary of average scores based on data generated using a non-uniform recombination rate with standard deviations in parentheses.')
```


```{r, fig.height=3, fig.cap="\\label{fig: acc_spec_sens nonuniform} Plots of scores based on data generated using a non-uniform recombination rate."}
# Plot accuracy specificity and sensitifity
par(mfrow = c(1,3))
plot_acc_spec_sens(sites[1], isoRelate = FALSE)
plot_acc_spec_sens(sites[2], isoRelate = FALSE)
plot_acc_spec_sens(sites[3], isoRelate = FALSE)
```


```{r, fig.cap = "\\label{fig: assignment nonuniform} Illustrative assignment plots for a randomly selected pairwise comparison based on chimeric child from Thies generated using a non-uniform recombination rate."}
# Plot example comparison
set.seed(1)
site <- "Thies"
comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
parent_assignment <- parent_assignment_sites[[site]] 
hmmIBD_assignment <- hmmIBD_assignment_sites[[site]] 
comp <- sample(comparisons_of_interest, 1)
plot_assignments(comp, isoRelate = FALSE)
```


```{r, fig.height=3, fig.cap="\\label{fig: no. gen nonuniform} Histograms of numbers of generations estimated from data generated using a non-uniform recombination rate. The true number of generations equal to one is denoted by a dashed vertical line."}
### Plots estimates of numbers of generations
hmmIBD_output_path <- '../pf3k_chimeric_data/hmmIBD_nonuniform_%s.hmm_fract.txt'
par(mfrow = c(1,3), pty = 's')
for(site in sites){
  comparisons_of_interest <- comparisons_of_interest_sites[[site]]  
  X <- read.table(sprintf(hmmIBD_output_path, site), header = TRUE)
  haplo_21 <- apply(X[,c('sample2', 'sample1')], 1, paste, collapse = ' ')
  ind <- haplo_21 %in% comparisons_of_interest 
  no_gen_hap <- X$N_generation[ind]
  hist(no_gen_hap, col = which(sites == site) + 1, xlim = c(0, max(no_gen_hap)), 
       breaks = 20, main = site, xlab = 'Number of generations')  
  abline(v = 1, lty = 'dashed')
}
```


```{r, fig.height=3, fig.cap = '\\label{fig: post prob nonuniform} Posterior probabilities of the IBD state inferred from data generated using a non-uniform recombination rate.'}
# Posterior probabilities
plot_pos(hmmIBD_output_path)
```



---
title: "Appendix S3: comparative study of isoRelate and hmmIBD"
output: pdf_document
---

## Methods

### Summary of files and variables used

The following summarizes results generated from a comparative study of hmmIBD and isoRelate (Henden L, et al. BioRxiv. 2016). Analyses were based on data generated by artificial recombination (details below). The steps, data and scripts required to reproduce this study are as follows. 

1. Download the hmmIBD_benchmark repository from https://github.com/artaylor85/hmmIBD_benchmark and unzip the pf3k_data directory.
2. Install hmmIBD following instructions at https://github.com/glipsnort/hmmIBD/releases (v2.0.0).
3. Install isoRelate following instructions at https://github.com/bahlolab/isoRelate/releases (results here based on v0.1.0 installed Aug 9th 2017).
4. Set working directory to this source file location.
5. Run $\texttt{Simulate\_chimeric\_genotypes.R}$.
6. Run $\texttt{Run\_isolate\_hmmIBD.R}$. 
7. Run $\texttt{Post\_process\_results.R}$.
8. Run/knit this file. 

```{r setup, include=FALSE}
# Clear workspace, load libraries, specify magic numbers used
rm(list = ls()) 
inst_pkg_list <- rownames(installed.packages())
if("knitr" %in% inst_pkg_list){# For tables from matrices
  library(knitr) 
} else {
  install.packages("knitr")
  library(knitr)
}

# Magic numbers
load(file = '../pf3k_chimeric_data/Run_isoRelate_Magic_numbers.RData')
attach(Magic_numbers)
load(file = '../pf3k_chimeric_data/Simulate_chimeric_genotypes_Magic_numbers.RData')
attach(Magic_numbers)
rho <- as.character(signif(rho,3))

# Numbers of SNPs
load('../pf3k_chimeric_data/sites.RData')
nsnps <- rep(NA,3)
names(nsnps) <- sites
for(site in sites){
  load(sprintf('../pf3k_chimeric_data/parent_assignment_%s.RData', site))
  nsnps[site] <- nrow(parent_assignment)
  rm(parent_assignment)
}
```


### Simulation of artificially recombined data 

We used artificially recombined data to compare results generated under hmmIBD and isoRelate to a known truth that was not generated under either model. Artificially recombined data were based on the MalariaGen Pf3k samples, pilot release 5.0 (https://www.malariagen.net/projects/pf3k). These data were filtered prior to their use in this comparative study, leaving only single nucleotide polymorphisms (SNPs) in the accessible genome (as defined by Manske M, et al. Nature 2012), and those with a high probability of being monogenomic (ad defined by DEploid from Zhu SJ, Almagro-garcia J, Mcvean G. BioRxiv. 2017). The filtered data can be found in $\texttt{pf3k\_data}$. Using $\texttt{Simulate\_chimeric\_genotypes.R}$ we:

1.  Extracted samples from sites with `r min_num` or more samples (Thies, Kassena, Pursat). 
2.  For each site, removed multiallelic SNPs (unsupported by isoRelate) and those with minor allele frequency $\leq$ `r MAF`, leaving `r nsnps` SNPs per sample from `r names(nsnps)`, respectively. 
3.  Calculated and saved allele frequencies and data sets based on the non recombined data to ensure frequencies were not based on chimeric samples.
4.  For each pairwise comparison within a site, calculated the average identity-by-state, IBS (one minus the genome-wide average SNP difference), and plotted. 
5.  Extracted unrelated pairs (those with IBS < `r cutoff*100` percentile of the empirical IBS distribution). 
6.  Artificially recombined each unrelated sample pair to create a "chimeric child". Recombination was simulated by sampling crossover positions (in base pairs) from an exponential distribution with mean equal to the recombination rate (in M/bp) (see $\texttt{functions.R}$). 
7. Recorded the parent of each DNA segment in each chimeric child, and plotted the number of crossovers per chromosome averaged over all the chimeric children per site.  

<!-- UPDATE THIS SECTION WITH PARAMETERS USED TO RUN SH SCRIPTS -->
### Parameter values used to run the HMMs
For each site, IBD segments between `r n_children_to_analyse` "chimeric children" and each of their two parents were inferred under isoRelate and hmmIBD using the parameter values listed in the table below, some of which differ to the defaults provided in order to more closely match the two methods. Timing experiments were done separately on the first `r n_timing_samples_to_run` samples per site (including non-recombined parents and chimeric children), and repeated `r n_timing_repetition` times on a MacBook Air laptop with 1.7 GHz Intel Core i7 processor.  

Parameter |  isoRelate | hmmIBD
---------------------------------------------------------------- | ----------  | ----------
genotyping error | `r error_prob`  | 0.001
recombination rate | `r rho` M/bp$\dagger$ | `r  rho` M/bp
minimum no. SNPs per segment | `r min_snps` | NA
minimum length (bp) per segment | `r minimum_length_bp` | NA
Minimum marker spacing (bp) | NA | 0
Minimum informative sites per genome | NA | 0  

Table: Specified parameter values. NA denotes not applicable. $\dagger$In isoRelate, the "recombination rate" is a function of distance in Morgans (M). The equivalent fixed rate in M per base pair (bp) for hmmIBD was thus based on the empirical relationship between positions in bp and centimorgans provided in the png_pedmap data set of the isoRelate package. 

## Results

```{r, cache.comments = FALSE, echo = FALSE} 
time_store <- array(dim = c(length(sites)*n_timing_repetition,2,2), 
                    dimnames = list(paste(sites, rep(1:n_timing_repetition, each = length(sites))), c('isoRelate', 'hmmIBD'), c('real', 'user')))

# hmmIBD
load('../pf3k_chimeric_data/hmmIBD_timing_output.RData')

for(site in sites){
  for(i in 1:n_timing_repetition){
    
    # IsoRelate
    load(sprintf('../pf3k_chimeric_data/IsoRelate_timing_output_%s_%s.RData', site, i))
    
    # Extract
    time_store[paste(site, i), 'isoRelate', 'real'] <- results$time_my_ibd['elapsed']
    time_store[paste(site, i), 'hmmIBD', 'real'] <- time_my_ibd[[paste(site, i)]]['elapsed'] 
    time_store[paste(site, i), 'isoRelate', 'user'] <- results$time_my_ibd['user.child'] + results$time_my_ibd['user.self']
    time_store[paste(site, i), 'hmmIBD', 'user'] <- time_my_ibd[[paste(site, i)]]['user.child'] + time_my_ibd[[paste(site, i)]]['user.self']
  }
}

# Visually report times
kable(time_store[,,'real'], caption = sprintf('Clocktime (sec) per %s samples', n_timing_samples_to_run))

kable(time_store[,,'user'], caption = sprintf('CPU time (sec) per %s samples', n_timing_samples_to_run))

# Report average time (with CIs or range) 
mean_times_real <- colMeans(time_store[,,'real'])
mean_times_user <- colMeans(time_store[,,'user'])

# sds
se_real <- apply(time_store[,,'real'], 2, sd)
se_user <- apply(time_store[,,'user'], 2, sd)

# Average fold difference
fold_diff <- mean(time_store[,'isoRelate','user']/time_store[,'hmmIBD','user'])
```


Accuracy, sensitivity and specificity were calculated as follows, where for a given pairwise comparison and SNP, a true positive is an IBD observation given an IBD state, and a true negative is a not IBD (nIBD) observation given a nIBD state,  

\begin{align}
\text{Accuracy} &= \dfrac{\sum \text{ True positive} + \sum \text{ True negative}}{\text{Number of SNPs}},\\
\text{Sensitivity} &= \dfrac{\sum \text{ True positive}}{\sum \text{ IBD states}},\\
\text{Specificity} &= \dfrac{\sum \text{ True negative}}{\sum \text{ nIBD states}}.
\end{align}


```{r, cache.comments = FALSE, echo = FALSE}
# Accuracy, sensitivity and specificity stores 
accuracy <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))
sensitivity <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))
specificity <- array(dim = c(n_children_to_analyse*2, 2, length(sites)), dimnames = list(NULL, c('isoRelate', 'hmmIBD'), sites))

for(site in sites){
  
  load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_%s.RData',site))
  load(sprintf('../pf3k_chimeric_data/isoRelate_assignment_%s.RData', site))
  load(sprintf('../pf3k_chimeric_data/hmmIBD_assignment_%s.RData', site))
  load(sprintf('../pf3k_chimeric_data/parent_assignment_%s.RData', site))
  
  n_snps <- nsnps[site]
  
  # Aside: check NAs in hmmIBD output derive from the min. spacing arguement (all within 10bp)
  NAs_ind <- which(is.na(hmmIBD_assignment[,3]))
  NAs_before_ind <- NAs_ind-1
  NAs_after_ind <- NAs_ind+1
  after_win_10 <- (hmmIBD_assignment$pos[NAs_ind] - hmmIBD_assignment$pos[NAs_before_ind]) < 10
  before_win_10 <- (hmmIBD_assignment$pos[NAs_after_ind] - hmmIBD_assignment$pos[NAs_ind]) < 10
  if(any(!(after_win_10 | before_win_10))){print('Unexpected NAs in hmmIBD assignment')}
  
  for(i in 1:length(comparisons_of_interest)){
    
    # Extract parent of comparison
    samples <- strsplit(comparisons_of_interest[i], ' ')[[1]]
    parent <- sprintf('parent%s', which(strsplit(samples[1], split = ":")[[1]] == samples[2]))
    simulated <- parent_assignment[,strsplit(comparisons_of_interest[i], split = ' ')[[1]][1]]
    positive_simulated <- sum(simulated == parent)
    negative_simulated <- sum(simulated != parent)
    
    # Calculate accuracy isoRelate
    inferred_iso <- isoRelate_assignment[,comparisons_of_interest[i]]
    true_positive_iso <- sum(simulated == inferred_iso, na.rm = TRUE)
    true_negative_iso <- sum((simulated != parent) & (inferred_iso == 'DBD'), na.rm = TRUE) # Don't count NAs
    accuracy[i, 'isoRelate', site] <- (true_positive_iso + true_negative_iso)/n_snps  
    
    # Calculate accuracy hmmIBD
    inferred_hap <- hmmIBD_assignment[,comparisons_of_interest[i]]
    true_positive_hap <- sum(simulated == inferred_hap, na.rm = TRUE)
    true_negative_hap <- sum((simulated != parent) & (inferred_hap == 'DBD'), na.rm = TRUE) # Don't count NAs
    accuracy[i, 'hmmIBD', site] <- (true_positive_hap + true_negative_hap)/n_snps  
    
    # Calculate Sensitivity and specificity
    sensitivity[i, 'isoRelate', site] <- true_positive_iso/positive_simulated
    sensitivity[i, 'hmmIBD', site] <- true_positive_hap/positive_simulated
    specificity[i, 'isoRelate', site] <- true_negative_iso/negative_simulated
    specificity[i, 'hmmIBD', site] <- true_negative_hap/negative_simulated
  }
}

# Summarise for plots below
mean_accuracy <- apply(accuracy, c(2,3), mean) # isoRelate is highly accurate (masking NAs improves but marginally)
mean_sensitivity <- apply(sensitivity, c(2,3), mean) # Both highly sensitive
mean_specificity <- apply(specificity, c(2,3), mean) # Haplo IBD has low power 
```



```{r, cache.comments = FALSE, echo = FALSE}
# Define function to plot 
plot_assignments <- function(comp){
  
  # Determin if a comparison with parent1 or parent2? 
  samples <- strsplit(comp, split = ' ')[[1]]
  child_ind <- grepl(":", samples)
  child <- samples[child_ind]
  parent <- sprintf('parent%s', which(strsplit(child, split = ":" )[[1]] == samples[!child_ind]))
  
  # Exract and colour assignment
  sim <- parent_assignment[,child]
  parentcol <- c(parent1 = 'blue', parent2 = 'pink')
  sim[sim == 'parent1'] <- parentcol['parent1']
  sim[sim == 'parent2'] <- parentcol['parent2']
  
  hap <- hmmIBD_assignment[,comp]
  hap[hap == parent] <- parentcol[parent]
  hap[hap == 'DBD'] <- 'gray'
  hap[is.na(hap)] <- 'black'
  
  iso <- isoRelate_assignment[,comp]
  iso[iso == parent] <- parentcol[parent]
  iso[iso == 'DBD'] <- 'gray'
  iso[is.na(iso)] <- 'black'
  
  # Get chromosome lengths
  chr_length <- read.csv(file = '../pf3k_data/Pf_v3_chrom_length.csv', 
                         skip = 2, header = FALSE)[,'V3']
  
  # Plot set up 
  par(mfrow = c(3,1), mar = c(1,1,1,1))  
  
  # Simulated
  barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
  title(main = 'Simulated')
  legend('bottomright', legend = c('SNP inherited from parent 1', 'SNP inherited from parent 2'), 
         bty = 'n', 
         col = c(parentcol['parent1'], parentcol['parent2']), lty = 1, lwd = 2, inset = 0.15)
  for(chr in 1:14){
    indices <- which(parent_assignment[,'chrom'] == chr)
    for(ind in indices){
      segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
               x0 = parent_assignment$pos[ind], 
               x1 = parent_assignment$pos[ind], 
               col = sim[ind]) 
    }
  }
  
  # Inferred isoRelate
  barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
  title(main = 'Inferred under isoRelate')
  legend('bottomright', legend = c(sprintf('SNP IBD with %s', parent), 
                                   sprintf('SNP DBD with %s', parent), 'NA'), bty = 'n', 
         col = c(parentcol[parent], 'gray', 'black'), lty = 1, lwd = 2, inset = 0.15)
  for(chr in 1:14){
    indices <- which(parent_assignment$chrom == chr)
    for(ind in indices){
      segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
               x0 = parent_assignment$pos[ind], 
               x1 = parent_assignment$pos[ind], 
               col = iso[ind]) 
    }
  }
  
  # Inferred hmmIBD
  barplot_pos <- barplot(chr_length, bty = 'n', horiz = TRUE, xaxt = 'n', col = 'white')
  title(main = 'Inferred under hmmIBD')
  legend('bottomright', legend = c(sprintf('SNP IBD with %s', parent), 
                                   sprintf('SNP DBD with %s', parent), 'NA'), bty = 'n', 
         col = c(parentcol[parent], 'gray', 'black'), lty = 1, lwd = 2, inset = 0.15)  
  for(chr in 1:14){
    indices <- which(parent_assignment$chrom == chr)
    for(ind in indices){
      segments(y0 = barplot_pos[chr,1]-0.4, y1 = barplot_pos[chr,1]+0.4, 
               x0 = parent_assignment$pos[ind], 
               x1 = parent_assignment$pos[ind], 
               col = hap[ind]) 
    }
  } 
}
```



```{r, cache.comments = FALSE, echo = FALSE}
site <- sites[1]
plot(NULL, ylim = c(0,1), xlim = c(0,1), bty = 'n', main = site, 
     xlab = 'False positive rate (1-specificity)', ylab = 'True positive rate (sensitivity)')
title(sub = sprintf('Mean accuracy %s (isoRelate) %s (hmmIBD)', round(mean_accuracy[,site],4)['isoRelate'], round(mean_accuracy[,site],4)['hmmIBD']))

points(y = sensitivity[, 'isoRelate', site], x = (1-specificity[, 'isoRelate', site]), 
       col = adjustcolor('darkgreen', alpha.f = 0.5), pch = 20)
abline(h = mean_sensitivity['isoRelate', site], 
       v = 1-mean_specificity['isoRelate', site], col = 'darkgreen', lty = 'dashed')

points(y = sensitivity[, 'hmmIBD', site], x = (1-specificity[, 'hmmIBD', site]), 
       col = adjustcolor('blue', alpha.f = 0.5), pch = 20)
abline(h = mean_sensitivity['hmmIBD', site], 
       v = 1-mean_specificity['hmmIBD', site], col = 'blue', lty = 'dashed')

legend('right', legend = c('isoRelate single comparison', 'hmmIBD single comparison', 'isoRelate mean', 'hmmIBD mean'), 
       col = c('darkgreen', 'blue', 'darkgreen', 'blue'), pch = rep(20, 20, NA, NA), 
       pt.cex =  c(1, 1, 0, 0), lty = c(0, 0, 2, 2), bty = 'n', cex = 0.8)
```



```{r, cache.comments = FALSE, echo = FALSE}
# Pursat
site <- sites[2]
plot(NULL, ylim = c(0,1), xlim = c(0,1), bty = 'n', main = site,
     xlab = 'False positive rate (1-specificity)', ylab = 'True positive rate (sensitivity)')
title(sub = sprintf('Mean accuracy %s (isoRelate) %s (hmmIBD)', round(mean_accuracy[,site],4)['isoRelate'], round(mean_accuracy[,site],4)['hmmIBD']))

points(y = sensitivity[, 'isoRelate', site], x = (1-specificity[, 'isoRelate', site]), 
       col = adjustcolor('darkgreen', alpha.f = 0.5), pch = 20)
abline(h = mean_sensitivity['isoRelate', site], 
       v = 1-mean_specificity['isoRelate', site], col = 'darkgreen', lty = 'dashed')

points(y = sensitivity[, 'hmmIBD', site], x = (1-specificity[, 'hmmIBD', site]), 
       col = adjustcolor('blue', alpha.f = 0.5), pch = 20)
abline(h = mean_sensitivity['hmmIBD', site], 
       v = 1-mean_specificity['hmmIBD', site], col = 'blue', lty = 'dashed')

legend('right', legend = c('isoRelate single comparison', 'hmmIBD single comparison', 'isoRelate mean', 'hmmIBD mean'), 
       col = c('darkgreen', 'blue', 'darkgreen', 'blue'), pch = rep(20, 20, NA, NA), 
       pt.cex =  c(1, 1, 0, 0), lty = c(0, 0, 2, 2), bty = 'n', cex = 0.8)
```



```{r, cache.comments = FALSE, echo = FALSE}
site <- sites[3]
plot(NULL, ylim = c(0,1), xlim = c(0,1), bty = 'n', main = site,
     xlab = 'False positive rate (1-specificity)', ylab = 'True positive rate (sensitivity)')
title(sub = sprintf('Mean accuracy %s (isoRelate) %s (hmmIBD)', round(mean_accuracy[,site],4)['isoRelate'], round(mean_accuracy[,site],4)['hmmIBD']))

points(y = sensitivity[, 'isoRelate', site], x = (1-specificity[, 'isoRelate', site]),
       col = adjustcolor('darkgreen', alpha.f = 0.5), pch = 20)
abline(h = mean_sensitivity['isoRelate', site],
       v = 1-mean_specificity['isoRelate', site], col = 'darkgreen', lty = 'dashed')

points(y = sensitivity[, 'hmmIBD', site], x = (1-specificity[, 'hmmIBD', site]),
       col = adjustcolor('blue', alpha.f = 0.5), pch = 20)
abline(h = mean_sensitivity['hmmIBD', site],
       v = 1-mean_specificity['hmmIBD', site], col = 'blue', lty = 'dashed')

legend('right', legend = c('isoRelate single comparison', 'hmmIBD single comparison', 'isoRelate mean', 'hmmIBD mean'),
       col = c('darkgreen', 'blue', 'darkgreen', 'blue'), pch = rep(20, 20, NA, NA),
       pt.cex =  c(1, 1, 0, 0), lty = c(0, 0, 2, 2), bty = 'n', cex = 0.8)
```




### Illustrative assignment plots for two random pairwise comparison from Kassena
```{r, cache.comments = FALSE, echo = FALSE}
site <- "Kassena"
load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_%s.RData',site))
load(sprintf('../pf3k_chimeric_data/isoRelate_assignment_%s.RData',site))
load(sprintf('../pf3k_chimeric_data/hmmIBD_assignment_%s.RData',site))
load(sprintf('../pf3k_chimeric_data/parent_assignment_%s.RData',site))

set.seed(1)
comp1 <- sample(comparisons_of_interest, 1)
plot_assignments(comp1)

comp2 <- sample(comparisons_of_interest, 1)
plot_assignments(comp2)
```





### Estimates of numbers of generations

Both methods over estimate the number of generations:

```{r, cache.comments = FALSE, echo = FALSE}
par(mfrow = c(1,3), pty = 's')
for(site in sites){
  
  # hmmIBD
  load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_%s.RData',site))
  X <- read.table(sprintf('../pf3k_chimeric_data/hmmIBD_%s.hmm_fract.txt', site), header = TRUE)
  haplo_21 <- apply(X[,c('sample2', 'sample1')], 1, paste, collapse = ' ')
  ind <- haplo_21 %in% comparisons_of_interest # all in 21 (ordering)
  no_gen_hap <- X$N_generation[ind]
  
  # isoRelate
  load(sprintf('../pf3k_chimeric_data/IsoRelate_output_%s.RData', site))
  Y <- results$my_parameters
  haplo_21 <- apply(Y[,c('iid2', 'iid1')], 1, paste, collapse = ' ')
  ind <- haplo_21 %in% comparisons_of_interest # all in 21 (ordering)
  no_gen_iso <- Y$m[ind] # ind as above since Haplo_assignment and iso_assignment have the same dimnames
  
  plot(x = no_gen_hap, y = no_gen_iso, bty = 'n',
       pch = 20, col = adjustcolor(which(sites == site) + 1, alpha.f = 0.5),
       main = site, 
       xlab = c('hmmIBD'), 
       ylab = c('isoRelate'), 
       xlim = c(0,max(c(no_gen_hap, no_gen_iso))), 
       ylim = c(0,max(c(no_gen_hap, no_gen_iso))))
  points(1,1, pch = 20)
  abline(a = 0, b = 1)
}
```


### hmmIBD posterior probability of IBD versus proportion simulated IBD 

```{r, cache.comments = FALSE, echo = FALSE}
par(mfrow = c(1,3), pty = 's')

for(site in sites){
  
  # hmmIBD
  load(sprintf('../pf3k_chimeric_data/comparisons_of_interest_%s.RData',site))
  X <- read.table(sprintf('../pf3k_chimeric_data/hmmIBD_%s.hmm_fract.txt', site), header = TRUE)
  haplo_21 <- apply(X[,c('sample2', 'sample1')], 1, paste, collapse = ' ')
  rownames(X) <- haplo_21
  ind <- haplo_21 %in% comparisons_of_interest # all in 21 (not that %in% doesn't conserve order)
  post_prob_hap <- X[ind,][comparisons_of_interest, 'fract_sites_IBD'] # closest thing
  
  # Simulated 
  positive_simulated <- rep(NA, length(comparisons_of_interest))
  names(positive_simulated) <- comparisons_of_interest
  load(sprintf('../pf3k_chimeric_data/parent_assignment_%s.RData', site))
  n_snps <- nsnps[site]
  
  for(i in comparisons_of_interest){
    samples <- strsplit(i, ' ')[[1]]
    parent <- sprintf('parent%s', which(strsplit(samples[1], split = ":")[[1]] == samples[2]))
    simulated <- parent_assignment[,strsplit(i, split = ' ')[[1]][1]]
    positive_simulated[i] <- sum(simulated == parent)
  }
  
  
  plot(x = positive_simulated/n_snps, y = post_prob_hap, bty = 'n',
       pch = 20, col = adjustcolor(which(sites == site) + 1, alpha.f = 0.5),
       xlab = c('Simulated'), 
       ylab = c('hmmIBD'), 
       xlim = c(0,1), 
       ylim = c(0,1))
  
  abline(a = 0, b = 1, lty = 'dotted')
}
```


## Summary

Both isoRelate and hmmIBD are highly accurate, sensitive and specific. In addition to IBD segments, hmmIBD returns the posterior IBD proportion (a measure of relatedness that integrates over all possible IBD segment assignments). Under this present version of isoRelate, posterior proportion are not readily accessible, but many auxiliary functions for visualizing model output and assessing significance are provided. On average, hmmIBD was `r round(fold_diff, 0)` times faster in user CPU time than isoRelate.   

```{r, cache.comments = FALSE, echo = FALSE}
summary_table <- cbind('Clock time (sec)' = c(sprintf('%s (%s)', round(mean_times_real,
                                                                       3)['isoRelate'],round(se_real['isoRelate'], 3)), 
                                              sprintf('%s (%s)', round(mean_times_real,
                                                                       3)['hmmIBD'],round(se_real['hmmIBD'], 3))),
                       'CPU time (sec)' = c(sprintf('%s (%s)', round(mean_times_user,
                                                                           3)['isoRelate'],round(se_user['isoRelate'], 3)), 
                                                  sprintf('%s (%s)', round(mean_times_user,
                                                                           3)['hmmIBD'],round(se_user['hmmIBD'], 3))),
                       'Accuracy' = c(sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['isoRelate'],
                                              round(apply(accuracy, 2, sd), 3)['isoRelate']), 
                                      sprintf('%s (%s)', 
                                              round(apply(accuracy, 2, mean), 3)['hmmIBD'],
                                              round(apply(accuracy, 2, sd), 3)['hmmIBD'])), 
                       'Sensitivity' = c(sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['isoRelate'],
                                                 round(apply(sensitivity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(sensitivity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(sensitivity, 2, sd), 3)['hmmIBD'])), 
                       
                       'Specificity' = c(sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['isoRelate'],
                                                 round(apply(specificity, 2, sd), 3)['isoRelate']), 
                                         sprintf('%s (%s)', 
                                                 round(apply(specificity, 2, mean), 3)['hmmIBD'],
                                                 round(apply(specificity, 2, sd), 3)['hmmIBD'])))

rownames(summary_table) <- c('isoRelate', 'hmmIBD') 
kable(summary_table, caption = sprintf('Summary of average scores (standard deviations). Times correspond to %s samples on a MacBook Air with 1.7 GHz Intel Core i7 processor.', n_timing_samples_to_run))
```
